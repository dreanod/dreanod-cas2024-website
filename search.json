[
  {
    "objectID": "part1_slides.html",
    "href": "part1_slides.html",
    "title": "Example page",
    "section": "",
    "text": "On this page, we set two options directly in the Quarto document. The rest of the options are coming from the _quarto.yml project file. These options are considered “global”.\nThe local options that we enabled are to show the webR status bar and to pre-install the ggplot2 package.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nIf we did not specify the package dependency in the document header, then we would need to add to the code cell the installation command of webr::install('ggplot2') prior to using library(ggplot2)."
  },
  {
    "objectID": "part3_slides.html",
    "href": "part3_slides.html",
    "title": "Example page",
    "section": "",
    "text": "On this page, we set two options directly in the Quarto document. The rest of the options are coming from the _quarto.yml project file. These options are considered “global”.\nThe local options that we enabled are to show the webR status bar and to pre-install the ggplot2 package.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nIf we did not specify the package dependency in the document header, then we would need to add to the code cell the installation command of webr::install('ggplot2') prior to using library(ggplot2)."
  },
  {
    "objectID": "part2_slides.html",
    "href": "part2_slides.html",
    "title": "Example page",
    "section": "",
    "text": "On this page, we set two options directly in the Quarto document. The rest of the options are coming from the _quarto.yml project file. These options are considered “global”.\nThe local options that we enabled are to show the webR status bar and to pre-install the ggplot2 package.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nIf we did not specify the package dependency in the document header, then we would need to add to the code cell the installation command of webr::install('ggplot2') prior to using library(ggplot2)."
  },
  {
    "objectID": "part2_workshop.html",
    "href": "part2_workshop.html",
    "title": "Actuarial Data Manipulation with R",
    "section": "",
    "text": "WebR will automatically load the packages that are required. This may take a few minutes."
  },
  {
    "objectID": "part2_workshop.html#package-loading",
    "href": "part2_workshop.html#package-loading",
    "title": "Actuarial Data Manipulation with R",
    "section": "",
    "text": "WebR will automatically load the packages that are required. This may take a few minutes."
  },
  {
    "objectID": "part2_workshop.html#exploring-policy-data",
    "href": "part2_workshop.html#exploring-policy-data",
    "title": "Actuarial Data Manipulation with R",
    "section": "2 Exploring Policy Data",
    "text": "2 Exploring Policy Data\n\n2.1 Load the policy table\nThis loads the policy table\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n2.2 Display the structure of the policy table\nPrinting the table will show a few rows and columns\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis is a typical dataset that you would find in an insurance company.\nThe table has 5 columns:\n\npolicy_id: a unique id for each policy written\ninception_date: the date at which the policy coverage starts\nexpiration_date: the date at which the policy coverage ends\npremium: the amount of written premium for the policy\nn_expo: the number of exposures covered by the policy\n\nHere are other functions you can use to have a quick overview of the data:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n2.3 Calculate summary statistics\nHigh-level information about the data can be obtained using the summarize() function that was introduce in the previous module.\n\n\n\n\n\n\nExercise 1.1\n\n\n\nUsing the summarize() function, calculate:\n\nthe average premium\nthe total premium\nthe total number of exposures\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.1\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n2.4 Filter the data using filter()\nIn general, statistics across many years are not very useful for actuarial analysis. Statistics for a single year are more interesting. The filter() function from dplyr can be used to select only the rows that correspond to a specific year.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nExercise 1.2\n\n\n\nUsing filter() and summarize(), calculate the average premium for policies written in 2011.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.2\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n2.5 Introducing the pipe |&gt;\nNotice how we had to create the variable df to store the result of filter() before sending it to summarize()? df is a temporary variable that is not reused and it tends to clutter the code.\nWhen manipulating data, we often chain operations, each function call one using the result from the previous function. In this case we are not interested in the intermediary results. The pipe operator |&gt; avoids the need to introduce temporary variables.\nIf we let x, y be variables and fun() a function, then x |&gt; fun() is equivalent to fun(x) and x |&gt; fun(y) is equivalent to fun(x, y)\n\n\n\n\n\n\nExercise 1.3\n\n\n\nRewrite the filter and summarize operation above using the pipe:\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.3\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n2.6 Grouping and summarizing\nThe summarize() function is useful to calculate statistics for the whole dataset. However, it is often more useful to calculate statistics for each group of a variable. In our case, we might want to calculate the average written premium for each year. This is done using the group_by() function:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis will return the average written premium for each year.\n\n\n\n\n\n\nExercise 1.4\n\n\n\nUsing group_by() and summarize(), calculate the total number of:\n\nwritten exposures for each year.\nwritten premium for each year.\nwritten policies for each year. (Hint: use n() in summarize()\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.4\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "part2_workshop.html#calculating-earned-premium",
    "href": "part2_workshop.html#calculating-earned-premium",
    "title": "Actuarial Data Manipulation with R",
    "section": "3 Calculating Earned Premium",
    "text": "3 Calculating Earned Premium\nCalculating the earned premium for each year is more complicated because we need to take into account the inception and expiration date of the policies to calculate the portion of the premium that is earned in a given year.\n\n3.1 Calculating earned premium for year 2010\nWe first calculate the earned_premium for a single year, 2010. First let us define the start and end dates of 2010, using the ymd() function from the lubridate package:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nExercise 2.1\n\n\n\nFind another function from lubridate that can be used to calculate the end of the year date with a date in the standard US format (mm/dd/yyyy). Hint: the function name should start with m.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.1\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\n\n\nExercise 2.2\n\n\n\nFilter the policies that are in-force in 2010, using the filter() function.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.2\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIf filter() is provided with multiple conditions, it will return only the rows that satisfy all conditions.\n\n\n\n\n\n\nExercise 2.3\n\n\n\nCreate two new columns in policy_df_2010 that contains the beginning date of the earning period (begin_earn_date) and the end date of the earning period (end_earn_date), over year 2010.\nHint: use the pmax() and pmin() functions from base R.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.3\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nTo calculate a duration between two dates using the functions from lubridate, there are two steps:\n\nDefine a period between the two dates using the %–% operator\nCalculate the duration of the period, by dividing it by a period object\n\nFor example to calculate the number of days between in 2010:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe + 1 is necessary because lubridate excludes the end date from the period, 12/31/2010 is included in year 2010. Generally, one need to be careful wit the boundaries when calculating durations, and in particular check whether the expiration date is included in the policy coverage period. Different companies might have different conventions.\n\n\n\n\n\n\nExercise 2.4\n\n\n\nAdd new columns in policy_df_2010 with:\n\nThe duration of each policy in policy_df_2010.\nThe number of days of the policy that are earned in 2010.\nThe ratio of policy earned in 2010 (nb_earn_days / policy_duration).\nThe premium earned in 2010 for each policy.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.4\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\n\n\nExercise 2.5\n\n\n\nCalculate the total premium earned in 2010\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.5\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n3.2 Calculating earned premium for years 2010 to 2014\nNow to calculate the earned premium for each year between 2010 and 2014 we need to loop over the years and redo the above calculation. The traditional way to approach this problem is through a for loop. However, mapping functions are a better alternative, because they lead to cleaner code. The R package purrr provides a set of mapping functions. The most basic one is map() which takes a minimum of two arguments:\n\nx, a vector of elements over which to iterate\nfun, a function to be called for each element of x\n\nCalling map(x, fun):w will return a list of the form:\nlist(fun(x[[1]]), fun(x[[2]]), ...)\n\n\n\n\n\n\nExercise 2.6\n\n\n\nUse map() to calculate the square of all numbers between 1 and 10\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.6\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nmap() always returns a list. Generally, this is not what we want. In this case, returning a vector of double is more appropriate.\n\n\n\n\n\n\nExercise 2.7\n\n\n\nUse the purrr cheatsheet to find which mapping function to use.\nHint: the functions is of the form map_*()\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.7\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIn many situations, it is very useful to return a data frame because more information can be returned in this way.\n\n\n\n\n\n\nExercise 2.8\n\n\n\nFind the mapping function that allows you to return a data frame, with one row per item in x. Use it to return a data frame with two columns, one for x and one for x squared.\nHint: you will have to modify the input function.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.8\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\n\n\nExercise 2.9\n\n\n\nLet’s now use the previous mapping function to create a data frame that has a column for the years (2010 to 2014) and a column for the corresponding earned premium.\nHint: the input function should take one argument for the year. Reuse the calculations for 2010 in the body of the function, just make them general for any year.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.9\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "part3_workshop.html",
    "href": "part3_workshop.html",
    "title": "Actuarial Data Manipulation with R",
    "section": "",
    "text": "WebR will automatically load the packages needed for this module. This may take a few minutes."
  },
  {
    "objectID": "part3_workshop.html#package-loading",
    "href": "part3_workshop.html#package-loading",
    "title": "Actuarial Data Manipulation with R",
    "section": "",
    "text": "WebR will automatically load the packages needed for this module. This may take a few minutes."
  },
  {
    "objectID": "part3_workshop.html#building-triangle-data",
    "href": "part3_workshop.html#building-triangle-data",
    "title": "Actuarial Data Manipulation with R",
    "section": "2 Building Triangle Data",
    "text": "2 Building Triangle Data\nIn many cases the data is not in the right format for actuarial analysis, and we need to transform it. This is the case for the claim transaction table that we will use in this module.\n\n2.1 Load the claim transaction table\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis is a typical dataset that you would find in an insurance company. One row corresponds to a transaction on a claim (e.g., a payment or a reserve change) The claim transaction table has the following columns:\n\nclaim_id: a unique id for each claim\naccident_date: the date at which the accident occurred\nevaluation_date: the date at which the transaction was evaluated\npayment_amount: the amount paid for the transaction\nchange_in_reserve: the change in the reserve for the claim\n\n\n\n\n\n\n\nExercise 1.1\n\n\n\nThe columns accident_date and evaluation_date are provided as character strings. Use the mdy() function from the lubridate package to convert them to date objects.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.1\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIn this module, we will develop reported (incurred) claims to ultimate.\n\n\n\n\n\n\nExercise 1.2\n\n\n\nAdd a new column to the transactions_df data frame called incremental_incurred with the incremental change to incurred value after each transaction.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.2\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n2.2 Calculate one Value of the Reported Triangle\n\n\n\n\n\n\nExercise 1.3\n\n\n\nLet us calculte one value of the reported triangle. We will calculate the cumulative incurred value claims occurring in 2010 at 45 months of maturity.\n\nFilter the transactions for claims occurring in 2010.\nFilter the transaction for these claims at 45 months of maturity. (Hint: The evaluation date of the transaction should be less than or equal to the start of the accident year + 45 months. Use functions ymd()/mdy() and months() from lubridate)\nCalculate the cumulative incurred value for these transactions.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.3\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n2.3 Calculate the Full Triangle Data\nIn the above exercise we calculated one value of the reported triangle. We can use the same logic to calculate all the values of the reported triangle. The best apporach is to first create a new data frame with all the possible combinations of accident year and maturity.\nWe will use the crossing() function from the tidyr package. This function creates a new data frame with all the possible combinations of the columns provided as arguments.\nFor example, this will create a data frame with 4 rows:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nExercise 1.4\n\n\n\n\nCreate a new triangle_df data frame with all the possible combinations of accident year and maturity. The maturity should be in months and should range from 21 to 129 in steps of 12 months. (hint: Use the seq() function with the by = argument to create the maturity column)\nAdd two new columns to the triangle_df data frame:\n\n\ncohort_start_date: the start date of the cohort (use the ymd() function with paste0() to create the date)\nevaluation_date: the evaluation date of the reported losses from the cohort (add maturity months to the cohort start date and subtract 1 day)\n\n\nFilter the triangle_df data frame to keep only the rows where the evaluation_date is less than or equal to the last possible evaluation date (hint: find the last possible evaluation date by looking at the spreadsheet)\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.4\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\n\n\nExercise 1.5\n\n\n\nWe can now calculate the cumulative incurred losses for each row triangle_df. 1. Write a function calculate_cumulative_incurred() that takes as arguments the accident_year and maturity, and calculates the cumulative incurred value for the cohort. (hint: reuse the code from exercise 1.3) 2. Use the pmap_dbl() function from the purrr package to apply the calculate_cumulative_incurred() function to each row of the triangle_df data frame. pmab_dbl() iterates over the rows of the data frame and applies the function to each row. It returns a numeric vector with the results. (hint: add the catch-all ... argument in the calculate_cumulative_incurred() function to ignore the other columns of the triangle_df data frame) 3. Add the cumulative_incurred column to the triangle_df data frame.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.5\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n—– 1.4 Pivot the Triangle Data —————————————— The triangle data obtained in the previous steps is in a long format. We will pivot it to a wide format to see it the way it is usually presented. ::: {.callout-caution} #### Exercise 1.6 1. Use the select() function from the dplyr package to remove the cohort_start_date and evaluation_date columns from the triangle_df data frame. 2. Use the pivot_wider() function from the tidyr package to pivot the triangle_df data frame to a wide format. The pivot_wider() function takes the following arguments: * data: the data frame to pivot (triangle_df) * names_from: the column to use for the column names of the new data frame (maturity) * values_from: the column to use for the values of the new data frame (cumulative_incurred) :::\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.6\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nWhen the triangle data is in a wide format, it is more appropriate to use a matrix to store it. We can convert the triangle data frame to a matrix using the as.matrix() function. ::: {.callout-caution} #### Exercise 1.7 1. Convert the triangle data frame to a matrix and set the row names to the accident years. (hint: remove the first column of the triangle data frame before converting it to a matrix) 2. Add the dimension names to the matrix. The dimension names should be “accident_year” and “maturity”. :::\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.7\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n2. Developing Claims to Ultimate\nIn this section, we will develop the reported claims to ultimate using the the chain-ladder approach. —– 2.1 Age-to-Age Factors ———————————————— The first step in the chain-ladder method is to calculate the age-to-age factors. The library ChainLadder provides the function ata() to calculate the age-to-age factors. The ata() function takes a triangle matrix as input and returns the age-to-age factors. install.packages(“ChainLadder”)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can also calculate the age-to-age factors manually by dividing each element of the triangle matrix by the element in the previous column. ::: {.callout-caution} #### Exercise 2.1 1. Calculate the age-to-age factors manually by dividing each element of the’ triangle matrix by the element in the previous column. (hint: you can do this by dividing two shifted subsets of the triangle matrix) 2. Remove the last row of the resulting matrix. 3. Add the column names to the resulting matrix. The column names should be the combination of the maturity years. (hint: use the paste() function with the colnames() function to create the column names) :::\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.1\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThe next step is to select the age-to-age factors, often an average of the age-to-age factors from the age-to-age matrix. ::: {.callout-caution} #### Exercise 2.2 Calculate the simply weighted age-to-age factors by taking the average of the age-to-age factors in each column of the ata_matrix. (hint: use the apply() function with the mean() function, and na.rm = TRUE to ignore the missing values) :::\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.2\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\n\n\nExercise 2.3\n\n\n\nIn many cases, the dollar-weighted age-to-age factors are used instead of the simply weighted age-to-age factors. 1. Using apply(), calculate the dollar-weighted age-to-age factors by dividing the sum of each column of the triangle matrix by the sum of the previous column. (hint: take subsets of the triangle matrices, and make sure to replace the remove the extra value in the denominator, for example by setting it to NA)\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.3\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n—– 2.2 Age-to-Ultimate Factors —————————————— The next step is to calculate the age-to-ultimate factors. ::: {.callout-caution} #### Exercise 2.4 Assuming we have selected the dollar-weighted age-to-age factors, calculate the age-to-ultimate factors. We assume that the tail factor is 1. (hint: use the function cumprod() to calculate the cumulative products and the rev() function to reverse the order of the elements) :::\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.4\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n—– 2.3 Ultimate Claims ————————————————– The final step is to calculate the ultimate claims. It is easier to do this by working on data frames instead of matrices. ::: {.callout-caution} #### Exercise 2.5 Create a new data frame age2ult_df with the age-to-ultimate factors. The data frame should have two columns: maturity and the corresponding age-to-ultimate factor. Add a row with the last possible maturity (129) and the tail factor (1). :::\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.5\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\n\n\nExercise 2.6\n\n\n\n\nFilter the triangle_df data frame to keep only the latest evaluation_date for each accident_year. You will need to do a group-filter operation. First group the rows by accident_year, with group_by(), then filter the rows with the maximum maturity in each group with filter() and max().\nAdd a new column to triangle_df with the age-to-ultimate factor. To do this we left join triangle_df with age2ult_df on the column “maturity”. Use the dplyr function left_join(). (hint: new_df &lt;- left_join(left_df, right_df, by = “joining_column”)\nCalculate the ultimate claims by multiplying the cumulative incurred column by the age-to-ultimate factor column.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.6\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "WS-1: Actuarial Data Manipulation with R",
    "section": "",
    "text": "12:00 PM – 4:00 PM\nBecause of its statistical and graphical capabilities, R has become part of the actuarial toolkit. However, actuaries often lack systematic training in manipulating data using R.\nIn this session, we review fundamental R data structures and their application to insurance data. Participants will learn to perform basic actuarial procedures using modern data manipulation libraries (tidyverse).\nWe will cover different aspects of a reserving and ratemaking workflow (policy/claim data manipulation, rating, loss development, indications), with examples taken from CAS Exam 5 study notes (Werner, Appendix C). In each module, we will discuss practical R programming problems in small groups.\nParticipants will gain a better grasp of R data structures and their application to insurance data. They will be able to script basic data manipulation pipelines that perform routine actuarial procedures. Participant should have basic programming skills, as well as some experience performing actuarial procedures."
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "WS-1: Actuarial Data Manipulation with R",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nSelect the most appropriate R data structure to represent different types of actuarial concepts: vector, list, data frame, array, date, etc.\nWrite R scripts that load, manipulate and export insurance data, using state-of-the-art libraries: tidyverse, dplyr, lubridate, purrr, etc.\nPerform simple standard actuarial procedures in R: aggregate claim/policy data, calculate summary ratios, calculate and develop claim triangles, etc."
  },
  {
    "objectID": "part1_workshop.html",
    "href": "part1_workshop.html",
    "title": "Actuarial Data Manipulation with R",
    "section": "",
    "text": "WebR will automatically load the packages you need for this module. This may take a few minutes.\nIn this module, we will use the dplyr package. This package is part of the tidyverse, a collection of packages that work well together and are designed to make data analysis easier."
  },
  {
    "objectID": "part1_workshop.html#packages",
    "href": "part1_workshop.html#packages",
    "title": "Actuarial Data Manipulation with R",
    "section": "",
    "text": "WebR will automatically load the packages you need for this module. This may take a few minutes.\nIn this module, we will use the dplyr package. This package is part of the tidyverse, a collection of packages that work well together and are designed to make data analysis easier."
  },
  {
    "objectID": "part1_workshop.html#introduction-to-vectors",
    "href": "part1_workshop.html#introduction-to-vectors",
    "title": "Actuarial Data Manipulation with R",
    "section": "2 Introduction to Vectors",
    "text": "2 Introduction to Vectors\nThe most basic data structure in R is the vector. A vector is a 1-dimensional array of values of the same type (double, integer, character, logical). For example we can store the annual earned premium in a vector:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nearned_premium is the variable that will refers to the vector object. &lt;- assigns a value/object to a variable. It’s equivalent to =. c() is a function that creates a vector by concatenating all of its arguments together.\n\n2.1 Subsetting Vectors\nYou can access a particular value through its index. For example to access the earned premium for the first year:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nNote: In R, indices start at 1, not 0 like in some other programming languages.\n\n\nFor extracting the first 3 earned_premium you need to do:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nExercise 1.1\n\n\n\nRetrieve the premiums for:\n\nyears 2 to 5?\n2 and 4 only? (hint: use the function c())\nyear 4 to the end? (hint: use the function length() to know that is the index of the last value)\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.1\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n2.2 Named Vectors\nOne problem with vectors is this is that you have to remember that index 1 corresponds to year 2010 for example. This can be confusing. One thing that can help is to name the vector. This way you can access the value by the year instead of the index. The syntax for naming a vector is:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow we can get the premium for year 2010 using this command:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nExercise 1.2\n\n\n\nRetrieve the premium for years:\n\n2011 through 2013?\n2011 and 2014?\n\nHint: use the as.character() function to convert the years to character, because the names of the vector are always characters.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.2\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nNamed vectors provide more context to the values in the vector. But we will see that data frames can do the same and are more powerful in practice.\n\n\n2.3 Vectorized Operations\n\n\n\n\n\n\nExercise 1.3\n\n\n\nLet’s now calculate the on-level premium. (Actual premium times the current rate level factor). Here is the current rate level factor:\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.3\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nYou might be tempted to use a for loop to do this. There are two reasons why you should avoid using for loops in R:\n\nMany functions are optimized to work on vectors. Using for loops will result in less efficient code\nVectorized code is usually cleaner and more understandable. Which means it’s easier to debug and less work to maintain.\n\nGenerally, if you find yourself using a loop try to think hard how you could avoid it.\n\n\n\n\n\n\n\n\nExercise 1.4\n\n\n\nCalculate the projected ultimate loss and ALAE loss ratio for every year, given the data below:\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.4\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\n\n\nExercise 1.5\n\n\n\nCalculate the aggregated projected loss ratio (The dollar-weighted projected ultimate loss and ALAE ratio for all years) Hint: use the sum() function\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 1.5\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "part1_workshop.html#introducing-data-frames",
    "href": "part1_workshop.html#introducing-data-frames",
    "title": "Actuarial Data Manipulation with R",
    "section": "3 Introducing data frames",
    "text": "3 Introducing data frames\nSo far we have only used the simple vector data structure to do all the calculations. For simple calculations like what we’ve done this is enough. However, when the complexity of the data of the operation increases this approach becomes unpractical:\n\nWe need to create a new variable for each new or derived attribute\nWe cannot easily filter what’s related to a single given year\n\nThe solution is to organize the data under the form of a table. This is exactly what a data frame is.\n\n3.1 Creating a data frame\nR comes with the base function data.frame() to create a data frame. This function is little less easy to use that tibble() which is loaded with the tidyverse package. (The tidyverse is a collection of packages that work well together and are designed to make data analysis easier.)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn essence a data frame bundles together a number of vector that are related. Therefore we can create a data frame from several vectors (of the same length) like this:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPrinting a data frame displays a nice table in the console In RStudio, you can also place the cursor on the variable name and press  to open a table viewer. ### Subsetting data frames You can extract a single vector using $:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTo add a new column, you can use $ along with the assignment operator:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nExercise 2.1\n\n\n\nAdd a new column to indication_df with the on-level premium.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.1\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n3.2 Modifying the columns with mutate()\nDo you notice how we repeat “indication_df$” three times? We can avoid this by using the dplyr function mutate():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nExercise 2.2\n\n\n\n\nUsing tibble(), create a new indication_df data frame that has the following columns (copy from the spreadsheet when needed):\n\n\naccident year\nearned premium\ncurrent rate level factor\nultimate loss and ALAE\nnet trend factor\n\n\nUsing mutate(), create these new columns (calculating from the ones above):\n\n\non-level premium\non-level ultimate loss and ALAE\nprojected ultimate loss and ALAE ratio\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.2\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n3.3 Selecting and renaming columns with select()\nAs you can see mutate() is quite a useful and flexible function. The dplyr package also provides select() to subset and reorder and rename columns. For example if you only need the projected LR for each year, and want to rename accident year to calendar year, you can do:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nExercise 2.3\n\n\n\n\nOnly select the year, projected premium, loss and loss ratio\nRename and reorder the columns as they appear in the spreadsheet Hint: You can use non-syntactic names (eg names that contain spaces) by enclosing them in backticks (``)\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.3\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n3.4 Summarizing data frames with summarize()\nThe dplyr package also provides a function summarize() to calculate summary statistics on a data frame.\nThe following calculates the total earned premium and ultimate losses\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn the following module, we will see how to group data and calculate summary statistics for each group.\n\n\n\n\n\n\nExercise 2.4\n\n\n\n\nCalculate the aggregated on-level earned premium, ultimate loss and loss ratio:\nCalculate the straight average projected LR?\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nSolution 2.4\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  }
]